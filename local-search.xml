<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>01背包问题</title>
    <link href="/2024/08/06/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2024/08/06/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。</p><p>第 i 件物品的体积是 $v_i$，价值是 $w_i$。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 N 行，每行两个整数  $v_i$,$w_i$，用空格隔开，分别表示第 i 件物品的体积和价值。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0&lt;N,V≤1000</p><p>0&lt;$v_i$, $w_i$≤10000</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>根据输入样例，我们可以得到如下表格:</p><table style = "width:100%">    <thead></thead>  <tbody>    <tr>      <td>序号</td>      <td>1</td>      <td>2</td>      <td>3</td>      <td>4</td>    </tr>    <tr>      <td>体积</td>      <td>1</td>      <td>2</td>      <td>3</td>      <td>4</td>    </tr>    <tr>      <td>价值</td>      <td>2</td>      <td>4</td>      <td>4</td>      <td>5</td>    </tr>  </tbody></table><p>通过表格，我们可以直观地看到，当选择物品2和3时，体积正好为5，并且价值有最大值为8。</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>像这类型题目，我们可以统称为01背包问题，即每件物品只能取一件，并且求其价值的最大值。对于这类型问题，我们可以通过<code>dp</code>的方式解决。    </p><p>首先定义状态，即<code>状态表示</code>为<code>f[i][j]</code>，表示前i个物品，体积为j的集合。<code>属性</code>为max，即价值的最大值。      </p><p><code>状态计算</code>:我们可以通过集合的方式进行状态计算，请看下图       </p>]]></content>
    
    
    <categories>
      
      <category>动态规划</category>
      
      <category>背包问题</category>
      
      <category>01背包问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>线性dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大盗阿福</title>
    <link href="/2024/07/27/%E5%A4%A7%E7%9B%97%E9%98%BF%E7%A6%8F/"/>
    <url>/2024/07/27/%E5%A4%A7%E7%9B%97%E9%98%BF%E7%A6%8F/</url>
    
    <content type="html"><![CDATA[<p>阿福是一名经验丰富的大盗。趁着月黑风高，阿福打算今晚洗劫一条街上的店铺。</p><p>这条街上一共有 N家店铺，每家店中都有一些现金。</p><p>阿福事先调查得知，只有当他同时洗劫了两家相邻的店铺时，街上的报警系统才会启动，然后警察就会蜂拥而至。</p><p>作为一向谨慎作案的大盗，阿福不愿意冒着被警察追捕的风险行窃。</p><p>他想知道，在不惊动警察的情况下，他今晚最多可以得到多少现金？</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入的第一行是一个整数 𝑇，表示一共有 T组数据。</p><p>接下来的每组数据，第一行是一个整数 N，表示一共有 N 家店铺。</p><p>第二行是 N 个被空格分开的正整数，表示每一家店铺中的现金数量。</p><p>每家店铺中的现金数量均不超过1000。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每组数据，输出一行。</p><p>该行包含一个整数，表示阿福在不惊动警察的情况下可以得到的现金数量。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤T≤50   </p><p>1≤N≤100000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">8</span> <span class="hljs-number">2</span><br><span class="hljs-number">4</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">14</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">8<br>24<br></code></pre></td></tr></table></figure><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>对于第一组样例，阿福选择第2家店铺行窃，获得的现金数量为8。</p><p>对于第二组样例，阿福选择第1和4家店铺行窃，获得的现金数量为10+14&#x3D;24。    </p><h5 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h5><p>状态机（State Machine），又称有限状态自动机（Finite State Machine, FSM），是一种用于描述系统行为或功能行为的数学模型。它通常包含一组状态、一组转换条件以及动作执行，通过在不同状态之间进行转换来模拟系统的行为。   </p><p>以上就是关于状态机的概念，通俗的解释就是状态之间的转移，以及转移所带来的效果。举个简单的例子，请看下图:</p><p><img src="https://cdn.jsdelivr.net/gh/Tiand1ddd/tuchuang@main/img/202407310023954.jpg" alt="状态转移样例"></p><p>根据上图，我们可以知道当n为正整数的时候，该状态转移可以称为简单的状态转移模型。</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>对于这道题，首先，我们考虑朴素做法，因为N的最大值为1e6，$n^2$的时间复杂度会超时，所以不可取，但是我们可以大概知道这道题正确解法的时间复杂度一定是O($n$)或者是O($nlogn$)的。   </p><p>这里我们需要根据前置知识引入一个新的dp模型–状态机模型。对于这道题，我们要将状态抽象出来，可以简单的通过定义0和1来表示当前的店铺有没有被抢劫。状态转移图如下所示:    </p><p><img src="https://cdn.jsdelivr.net/gh/Tiand1ddd/tuchuang@main/img/202408042226188.jpg" alt="状态转移图"></p><p><span style ="color:red;">状态表示</span>:<code>f[i][j]</code>:表示所有走了i步，且当前状态为j的所有走法，j的值只能为0或1   <code>f[i][j]</code>的值表示最大收益即max</p><p><span style = "color:red;">状态计算</span>:根据上面的状态转移图我们可以知道<code>f[i][1]</code>只能由<code>f[i-1][0]</code>转移而来，所以有<code>f[i-1][1]=f[i-1][0]+w[i]</code>，<code>f[i][0]</code>可由状态0和1转移而来，所以<code>f[i][0] = max(f[i-1][0]+w[i],f[i-1][1])</code></p><p>综上述，我们将最后的结果娶一个max即可，因为不知道最大收益的走法对于最后一个店铺是否抢劫，所以我们需要取一个max，即<code>max(f[n][0],f[n][1])</code>。代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>,INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> T,f[N][<span class="hljs-number">2</span>],w[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  cin&gt;&gt;T;<br>  <br>  <span class="hljs-keyword">while</span>(T--)&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;w[i]);<br>    <br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -INF,f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>      f[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],f[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);<br>      f[i][<span class="hljs-number">1</span>] = f[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+w[i];<br>    &#125;<br>    <br>    cout&lt;&lt;<span class="hljs-built_in">max</span>(f[n][<span class="hljs-number">0</span>],f[n][<span class="hljs-number">1</span>])&lt;&lt;endl;<br>  &#125;<br>  <br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><span style = "color:red">建议(tdk)</span>    </p><p>大道阿福这道题属于状态机模型的经典例题，里面只涉及到了两个状态的转移，相对好理解，并且我们可以知道有限状态自动机任意长度的路线都等价于某一方案，反之亦然！</p>]]></content>
    
    
    <categories>
      
      <category>动态规划</category>
      
      <category>状态机模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>状态机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字三角形</title>
    <link href="/2024/07/25/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2/"/>
    <url>/2024/07/25/%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<p>给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache">        <span class="hljs-attribute">7</span><br>      <span class="hljs-attribute">3</span>   <span class="hljs-number">8</span><br>    <span class="hljs-attribute">8</span>   <span class="hljs-number">1</span>   <span class="hljs-number">0</span><br>  <span class="hljs-attribute">2</span>   <span class="hljs-number">7</span>   <span class="hljs-number">4</span>   <span class="hljs-number">4</span><br><span class="hljs-attribute">4</span>   <span class="hljs-number">5</span>   <span class="hljs-number">2</span>   <span class="hljs-number">6</span>   <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n𝑛，表示数字三角形的层数。</p><p>接下来 n行，每行包含若干整数，其中第 i𝑖 行表示数字三角形第 i𝑖 层包含的整数。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大的路径数字和。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤5001</p><p>10000≤三角形中的整数≤10000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-number">7</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <br><span class="hljs-symbol">2 </span><span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">30<br></code></pre></td></tr></table></figure><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p><span style = "color: red;">状态表示</span>如果我们从三角形顶部向下转移状态不方便处理循环迭代操作，所以可以定义<code>f[i][j]</code>为从底部到(i,j)的数字和。   </p><p><span style = "color: red;">状态转移</span>因为是由底部向上,所以路径中的任一点(i,j)由(i+1,j)或(i+1,j+1)走来,可以通过max来求<code>f[i][j]</code>的最大值。转移方程为<code>f[i][j] = max(f[i+1][j],f[i+1][j+1])</code>    </p><p>c++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> f[N][N],w[N][N],n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  cin&gt;&gt;n;<br>  <span class="hljs-comment">//在处理输入的过程中，我们可以直接定义一个二维数组不必处理每一行前面的空格,不影响状态转移;</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=i;++j)&#123;<br>      cin&gt;&gt;w[i][j];<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">//在转移前要将f的最底层初始化,也可以不初始化,但是状态转移部分也就是下一个双重for循环i要从n开始,也就是最底层开始计算:</span><br>  <span class="hljs-comment">/* for(int i = n;i;--i)&#123;</span><br><span class="hljs-comment">    for(int j = 1;j&lt;=i;++j)&#123;</span><br><span class="hljs-comment">      f[i][j] = max(f[i+1][j],f[i+1][j+1])+w[i][j];</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">  &#125;*/</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;++i) f[n][i] = w[n][i];<br>  <span class="hljs-comment">//注意此处的遍历是从底部开始的,所以i从n-1开始;</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span>;i;--i)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=i;++j)&#123;<br>      f[i][j] = <span class="hljs-built_in">max</span>(f[i+<span class="hljs-number">1</span>][j],f[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>])+w[i][j];<br>    &#125;<br>  &#125;<br>  <br>  cout&lt;&lt;f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]&lt;&lt;endl;<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><span style = "color: red;">建议(tdk)</span>      </p><p>dp(dynamic programming)问题如果第一次见我们往往无从下手的,所以不要过度纠结自己为什么想不出来,而是牢牢地记住处理这一类型问题的思路,比如关于网格一类型的基本状态表示为f(i,j),数字三角形就是一个基础的关于网格当中路径问题的模型,接下来我们将会陆续归纳这一类型问题。</p>]]></content>
    
    
    <categories>
      
      <category>动态规划</category>
      
      <category>数字三角形模型</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dp</tag>
      
      <tag>线性dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tire树</title>
    <link href="/2024/07/11/Tire%E6%A0%91/"/>
    <url>/2024/07/11/Tire%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>tire树又叫字典树，是一种高效存储，查找一系列字符串的数据结构，我们在书写代码的过程中用到自动补全功能可以用tire树实现。      </p><p>为了掌握好tire树，我们需要解决以下几个问题:</p><ol><li>如何表示tire树？<br>通过定义一个二维数组来表示tire树，<code>tr[N][26]</code>。第一维表示有N个节点，因为每个字母后有26种可能，所以第二维为26，<code>tr[N][x-&#39;a&#39;]</code>的值表示下一个节点在第一维中的值，如果该值不为0，则表示字母x存在，并且通过tr数组的值检索或存储下一个节点的值，对于任意一个字符串的第一个字母x，都从树的根节点<code>tr[0][x-&#39;a&#39;]</code>开始向下存储。接下来我们举个简单的例子:</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>容斥原理</title>
    <link href="/2024/07/06/2024-7-6/"/>
    <url>/2024/07/06/2024-7-6/</url>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个整数 n𝑛 和 m𝑚 个不同的质数 p1,p2,…,pm𝑝1,𝑝2,…,𝑝𝑚。</p><p>请你求出 1∼n1∼𝑛 中能被 p1,p2,…,pm𝑝1,𝑝2,…,𝑝𝑚 中的至少一个数整除的整数有多少个。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>给定一个整数 n𝑛 和 m𝑚 个不同的质数 p1,p2,…,pm𝑝1,𝑝2,…,𝑝𝑚。第二行包含 m𝑚 个质数。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>给定一个整数 n𝑛 和 m𝑚 个不同的质数 p1,p2,…,pm𝑝1,𝑝2,…,𝑝𝑚。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤m≤16  1≤n,pi≤1091</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">7<br></code></pre></td></tr></table></figure><hr><p>知识提炼–容斥原理</p><p>样例解释:  定义集合S1，S2分别为能被2和3整数的数，所以有</p><p>​ S1 &#x3D; {2，4，6，8，10}  |S1| &#x3D; n&#x2F;p1 &#x3D; 10&#x2F;2 &#x3D; 5     S2 &#x3D; {3,6,9} |S2| &#x3D; 10&#x2F;3(下取整数) &#x3D; 3</p><p>​|S2∩S1| &#x3D; 10&#x2F;2*3 &#x3D; 1(下取整)</p><p>​根据容斥原理可以得到又能被2整除又能被3整数  |S1∪S2| &#x3D; |S1|+|S2| - |S1∩S2| &#x3D; 7</p><p>解题思路：设每个质数对应一个集合Si，该集合表示1~n中能被pi整数的数</p><p>​ 题目所求解为 |S1+S2+S3+…Sm| &#x3D; |S1|+|S2|+|S3|+….|Sm|-|S1∩S2|-|S1∩S3|-…..</p><p>题目难点:<strong>如何用代码实现对集合的分配，并且不重不漏</strong></p><p>​首先，对于给定的m个质数，可以通过遍历1~1&lt;&lt;m个数，对每个数的二进制位进行遍历得到质数集合编号，从而得到不重不漏的组合。根据容斥原理，可以得到集合个数是偶数进行减法操作，集合个数为奇数进行加法操作，核心代码以及完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;<span class="hljs-number">1</span>&lt;&lt;m;++i)&#123;<span class="hljs-comment">//遍历从1~1&lt;&lt;m个数</span><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">1</span>,s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;m;++j)&#123;<span class="hljs-comment">//对每个数的二进制位进行遍历</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> n,m,p[N];<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  cin&gt;&gt;n&gt;&gt;m;<br>  <br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;m;++i) cin&gt;&gt;p[i];<br>  <br>  ll res = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;<span class="hljs-number">1</span>&lt;&lt;m;++i)&#123;<br>    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>,t = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;m;++j)<br>      <span class="hljs-keyword">if</span>(i&gt;&gt;j &amp; <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>((ll)t*p[j] &gt; n)&#123;<br>          t = <span class="hljs-number">-1</span>;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>        t *= p[j];<br>        s++;<br>      &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(t != <span class="hljs-number">-1</span>)&#123;<br>      <span class="hljs-keyword">if</span>(s%<span class="hljs-number">2</span>) res += n/t;<br>      <span class="hljs-keyword">else</span> res -= n/t;<br>    &#125;<br>  &#125;<br>  <br>  cout&lt;&lt;res&lt;&lt;endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>容斥原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>容斥</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
